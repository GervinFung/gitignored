use std::{
    fs::{create_dir_all, read_to_string, File, OpenOptions},
    io::Write,
    panic,
    path::Path,
};
use strsim::normalized_levenshtein;

use crate::util::{GitIgnoreNameAndContentList, NameAndContentList, NameList, Str};

#[derive(Debug)]
struct Levenshtein {
    score: f64,
    closest: String,
    original: String,
}

impl Levenshtein {
    pub const fn new(score: f64, original: String, closest: String) -> Self {
        Levenshtein {
            score,
            original,
            closest,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Match {
    original: String,
    closest: String,
}

impl Match {
    pub const fn new(original: String, closest: String) -> Self {
        Match { original, closest }
    }

    pub fn original(&self) -> String {
        self.original.clone()
    }

    pub fn closest(&self) -> String {
        self.closest.clone()
    }
}

pub type Matches = Vec<Match>;

#[derive(Debug)]
pub struct SearchResult {
    exact: NameList,
    closest: Matches,
}

impl SearchResult {
    pub const fn new(exact: NameList, closest: Matches) -> Self {
        SearchResult { exact, closest }
    }

    pub fn exact(&self) -> NameList {
        self.exact.clone()
    }

    pub fn closest(&self) -> Matches {
        self.closest.clone()
    }
}

pub struct Templates {
    name_and_content_list_file_path: String,
}

impl Templates {
    pub fn new(cache: String) -> Self {
        Templates {
            name_and_content_list_file_path: format!(
                "{}/{}",
                cache, "gitIgnoreNamesAndContents.json"
            ),
        }
    }

    pub fn name_and_content_list(&self) -> NameAndContentList {
        let file_path = self.name_and_content_list_file_path.clone();
        let stringified_name_and_content_list = read_to_string(file_path.clone())
            .unwrap_or_else(|_| panic!("{} {}", "Unable to read from", file_path));
        let parsed: GitIgnoreNameAndContentList =
            serde_json::from_str(stringified_name_and_content_list.as_str()).unwrap_or_else(|_| {
                panic!(
                    "{} {}",
                    "Unable to parse as JSON from", stringified_name_and_content_list
                )
            });
        parsed.gitignored_name_and_content_list()
    }

    pub fn update_name_and_content_list(
        &self,
        name_and_content_list: NameAndContentList,
    ) -> NameAndContentList {
        let file_path = self.name_and_content_list_file_path.clone();
        let mut file = File::create(file_path.clone()).unwrap_or_else(|_| {
            panic!(
                "{} {}",
                "Unable to create name and content list cache file from", file_path
            )
        });
        let stringified = serde_json::to_string_pretty(&GitIgnoreNameAndContentList::new(
            name_and_content_list.clone(),
        ))
        .unwrap_or_else(|_| {
            panic!(
                "{} {:?}",
                "Unable to stringify name and content list of", name_and_content_list
            )
        });
        file.write_all(stringified.as_bytes()).unwrap_or_else(|_| {
            panic!(
                "{} {}",
                "Unable to write name and content list of", stringified
            )
        });
        self.name_and_content_list()
    }

    pub fn name_list(&self) -> NameList {
        self.name_and_content_list()
            .into_iter()
            .map(|name_and_content| name_and_content.name())
            .collect::<Vec<_>>()
    }

    pub fn filter_name_and_content_list(&self, name_list: Vec<String>) -> NameAndContentList {
        let name_list = name_list
            .iter()
            .map(|name| name.to_uppercase())
            .collect::<Vec<_>>();
        self.name_and_content_list()
            .into_iter()
            .filter(|name_and_content| name_list.contains(&name_and_content.name().to_uppercase()))
            .collect::<Vec<_>>()
    }

    pub fn generate_content(&self, api: Str, name_list: NameList) -> String {
        format!(
            "{} {}\n\n{}",
            "Generated by gitignore-cli. Templates are taken from",
            api,
            self.filter_name_and_content_list(name_list)
                .into_iter()
                .map(|name_and_content| {
                    format!(
                        "{} {}\n{}",
                        "### The gitignore of",
                        name_and_content.name().to_uppercase(),
                        name_and_content.content()
                    )
                })
                .collect::<Vec<_>>()
                .join("\n\n")
        )
    }

    pub fn generate_gitignore_outdir(&self, file_name: String) {
        let split = file_name.split('/').collect::<Vec<_>>();
        let len = split.len();
        create_dir_all(split.split_at(len - 1).0.join("/"))
            .unwrap_or_else(|_| panic!("{} {}", "Unable to create outdir from", file_name))
    }

    pub fn already_has_destination_file(&self, file_name: String) -> bool {
        Path::new(file_name.as_str()).exists()
    }

    pub fn generate_gitignore_file(&self, api: Str, name_list: NameList, file_name: String) {
        self.generate_gitignore_outdir(file_name.clone());
        let mut file = File::create(file_name.clone()).unwrap_or_else(|_| {
            panic!("{} {}", "Unable to create .gitignore file from", file_name)
        });
        file.write_all(self.generate_content(api, name_list).as_bytes())
            .unwrap_or_else(|_| {
                panic!(
                    "{} {}",
                    "Unable to write generated .gitignore to", file_name
                )
            })
    }

    pub fn append_gitignore_file(&self, api: Str, name_list: NameList, file_name: String) {
        self.generate_gitignore_outdir(file_name.clone());
        let gitignore = self.generate_content(api, name_list);
        let is_exist = self.already_has_destination_file(file_name.clone());
        let mut file = OpenOptions::new()
            .write(true)
            .append(is_exist)
            .create(!is_exist)
            .open(file_name.clone())
            .unwrap_or_else(|_| panic!("{} {}", "Unable to open/create file of", file_name));
        if !is_exist {
            file.write_all(gitignore.as_bytes()).unwrap_or_else(|_| {
                panic!(
                    "{} {}",
                    "Unable to write generated .gitignore content to", file_name
                )
            })
        } else {
            file.write_all(gitignore.to_string().as_bytes())
                .unwrap_or_else(|_| {
                    panic!(
                        "{} {}",
                        "Unable to append generated .gitignore content to", file_name
                    )
                })
        }
    }

    pub fn search_name_list(&self, name_list: Vec<&str>) -> SearchResult {
        let gitignored_name_list = self.name_list();
        let matches = name_list
            .iter()
            .map(|name| {
                let levenshtein = gitignored_name_list.iter().fold(
                    Levenshtein::new(0.0, name.to_string(), "".to_string()),
                    |prev, curr| {
                        if prev.score == 1.0 {
                            return prev;
                        }
                        let score = normalized_levenshtein(name, curr);
                        if score <= prev.score {
                            return prev;
                        }
                        Levenshtein::new(score, prev.original, curr.to_string())
                    },
                );
                Match::new(levenshtein.original, levenshtein.closest)
            })
            .collect::<Vec<_>>();
        SearchResult::new(
            matches
                .iter()
                .filter(|matches| {
                    matches.original().to_uppercase() == matches.closest().to_uppercase()
                })
                .map(|matches| matches.original())
                .collect::<Vec<_>>(),
            matches
                .into_iter()
                .filter(|matches| {
                    matches.original().to_uppercase() != matches.closest().to_uppercase()
                })
                .collect::<Vec<_>>(),
        )
    }
}

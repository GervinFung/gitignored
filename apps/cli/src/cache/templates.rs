use serde::{Deserialize, Serialize};
use std::{
    fs::{create_dir_all, read_to_string, File, OpenOptions},
    io::Write,
    panic,
    path::Path,
};
use strsim::normalized_levenshtein;

use crate::{
    api::response::{TemplateNames, Templates, TemplatesResponseDto},
    types::Str,
};

#[derive(Serialize, Deserialize, Debug)]
pub struct TemplaesDto {
    #[allow(non_snake_case)]
    templates: Templates,
}

#[derive(Debug)]
struct Levenshtein {
    score: f64,
    closest: String,
    original: String,
}

impl Levenshtein {
    pub const fn new(score: f64, original: String, closest: String) -> Self {
        Levenshtein {
            score,
            original,
            closest,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Match {
    original: String,
    closest: String,
}

impl Match {
    pub const fn new(original: String, closest: String) -> Self {
        Match { original, closest }
    }

    pub fn original(&self) -> String {
        self.original.clone()
    }

    pub fn closest(&self) -> String {
        self.closest.clone()
    }
}

pub type Matches = Vec<Match>;

#[derive(Debug)]
pub struct SearchResult {
    exact: TemplateNames,
    closest: Matches,
}

impl SearchResult {
    pub const fn new(exact: TemplateNames, closest: Matches) -> Self {
        SearchResult { exact, closest }
    }

    pub fn exact(&self) -> TemplateNames {
        self.exact.clone()
    }

    pub fn closest(&self) -> Matches {
        self.closest.clone()
    }
}

pub struct TemplatesCache {
    templates_file_path: String,
}

impl TemplatesCache {
    pub fn new(cache: String) -> Self {
        TemplatesCache {
            templates_file_path: format!("{}/{}", cache, "gitIgnoreNamesAndContents.json"),
        }
    }

    pub fn templates(&self) -> Templates {
        let file_path = self.templates_file_path.clone();

        let stringified_templates = read_to_string(file_path.clone())
            .unwrap_or_else(|_| panic!("Unable to read from {}", file_path));

        let parsed: TemplatesResponseDto = serde_json::from_str(stringified_templates.as_str())
            .unwrap_or_else(|_| panic!("Unable to parse as JSON from {}", stringified_templates));

        parsed.templates()
    }

    pub fn update_templates(&self, templates: Templates) -> Templates {
        let file_path = self.templates_file_path.clone();

        let mut file = File::create(file_path.clone()).unwrap_or_else(|_| {
            panic!(
                "Unable to create name and content list cache file from {}",
                file_path
            )
        });

        let stringified = serde_json::to_string_pretty(&TemplaesDto {
            templates: templates.clone(),
        })
        .unwrap_or_else(|_| {
            panic!(
                "Unable to stringify name and content list of {:?}",
                templates
            )
        });

        file.write_all(stringified.as_bytes())
            .unwrap_or_else(|_| panic!("Unable to write name and content list of {}", stringified));

        self.templates()
    }

    pub fn template_names(&self) -> TemplateNames {
        self.templates()
            .into_iter()
            .map(|template| template.name().clone())
            .collect::<Vec<_>>()
    }

    pub fn filter_templates(&self, template_names: Vec<String>) -> Templates {
        let names = template_names
            .iter()
            .map(|name| name.to_uppercase())
            .collect::<Vec<_>>();

        self.templates()
            .into_iter()
            .filter(|template| names.contains(&template.name().to_uppercase()))
            .collect::<Vec<_>>()
    }

    pub fn generate_content(&self, api: Str, template_names: TemplateNames) -> String {
        format!(
            "{} {}\n\n{}",
            "Generated by gitignore-cli. Templates are taken from",
            api,
            self.filter_templates(template_names)
                .into_iter()
                .map(|template| {
                    format!(
                        "{} {}\n{}",
                        "### The gitignore of",
                        template.name().to_uppercase(),
                        template.content()
                    )
                })
                .collect::<Vec<_>>()
                .join("\n\n")
        )
    }

    pub fn generate_gitignore_outdir(&self, file_name: String) {
        let split = file_name.split('/').collect::<Vec<_>>();

        create_dir_all(split.split_at(split.len() - 1).0.join("/"))
            .unwrap_or_else(|_| panic!("Unable to create outdir from {}", file_name))
    }

    pub fn already_has_destination_file(&self, file_name: String) -> bool {
        Path::new(file_name.as_str()).exists()
    }

    pub fn generate_gitignore_file(
        &self,
        api: Str,
        template_names: TemplateNames,
        file_name: String,
    ) {
        self.generate_gitignore_outdir(file_name.clone());

        let mut file = File::create(file_name.clone())
            .unwrap_or_else(|_| panic!("Unable to create .gitignore file from {}", file_name));

        file.write_all(self.generate_content(api, template_names).as_bytes())
            .unwrap_or_else(|_| panic!("Unable to write generated .gitignore to {}", file_name))
    }

    pub fn append_gitignore_file(
        &self,
        api: Str,
        template_names: TemplateNames,
        file_name: String,
    ) {
        self.generate_gitignore_outdir(file_name.clone());

        let gitignore = self.generate_content(api, template_names);

        let is_exist = self.already_has_destination_file(file_name.clone());

        let mut file = OpenOptions::new()
            .write(true)
            .append(is_exist)
            .create(!is_exist)
            .open(file_name.clone())
            .unwrap_or_else(|_| panic!("Unable to open/create file of {}", file_name));

        match is_exist {
            true => file
                .write_all(gitignore.to_string().as_bytes())
                .unwrap_or_else(|_| {
                    panic!(
                        "Unable to append generated .gitignore content to {}",
                        file_name
                    )
                }),
            false => file.write_all(gitignore.as_bytes()).unwrap_or_else(|_| {
                panic!(
                    "Unable to write generated .gitignore content to {}",
                    file_name
                )
            }),
        };
    }

    pub fn search_template_names(&self, template_names: Vec<String>) -> SearchResult {
        let gitignored_template_names = self.template_names();

        let perfect_score = 1.0;

        let matches = template_names
            .iter()
            .map(|name| {
                let levenshtein = gitignored_template_names.iter().fold(
                    Levenshtein::new(0.0, name.to_string(), "".to_string()),
                    |prev, curr| match prev.score == perfect_score {
                        true => prev,
                        false => {
                            let score = normalized_levenshtein(name, curr);

                            match score <= prev.score {
                                true => prev,
                                false => match score <= prev.score {
                                    true => prev,
                                    false => {
                                        Levenshtein::new(score, prev.original, curr.to_string())
                                    }
                                },
                            }
                        }
                    },
                );
                Match::new(levenshtein.original, levenshtein.closest)
            })
            .collect::<Vec<_>>();

        SearchResult::new(
            matches
                .iter()
                .filter(|matches| {
                    matches.original().to_uppercase() == matches.closest().to_uppercase()
                })
                .map(|matches| matches.original())
                .collect::<Vec<_>>(),
            matches
                .into_iter()
                .filter(|matches| {
                    matches.original().to_uppercase() != matches.closest().to_uppercase()
                })
                .collect::<Vec<_>>(),
        )
    }
}
